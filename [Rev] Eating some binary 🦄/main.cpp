#include <stdio.h>      // printf/scanf/fprintf
#include <string.h>     // strlen, strcmp, strftime (or replace)
#include <time.h>       // time, localtime, strftime (or replace)
#include <stdint.h>     // uint*_t (required by unicorn API)
#include "unicorn/unicorn.h"

// Syscall ABI registers (for reference)
// int syscall_abi[] = {
//     UC_X86_REG_ECX, UC_X86_REG_EDI, UC_X86_REG_ESI, UC_X86_REG_EDX,
//     UC_X86_REG_EBP, UC_X86_REG_ECX, UC_X86_REG_EBX
// };

// #define DEBUG

const int ADDRESS_CODE = 1 << 24;
const int ADDRESS_STAK = 2 << 24;
const int CODE_SIZE = 1 << 12;
const int STAK_SIZE = 4 << 12;
const int FLAG_ADDRESS = ADDRESS_STAK + STAK_SIZE - (1 << 8) + (2 << 4);

const uint8_t CORN[] = {
 0x0f, 0xb7, 0x02, 0x83, 0xc0, 0x10, 0x66, 0x89, 0x02, 0x0f, 0xb7, 0x42,
  0x2a, 0x83, 0xc0, 0x10, 0x66, 0x89, 0x42, 0x2a, 0x0f, 0xb7, 0x42, 0x36,
  0x83, 0xc0, 0x10, 0x66, 0x89, 0x42, 0x36, 0x0f, 0xb7, 0x42, 0x0e, 0x83,
  0xc0, 0x10, 0x66, 0x89, 0x42, 0x0e, 0x80, 0xf9, 0x00, 0x75, 0x02, 0x0f,
  0x05, 0x0f, 0xb7, 0x42, 0x2c, 0x0f, 0xb7, 0x1a, 0x33, 0xc3, 0x66, 0x89,
  0x42, 0x2c, 0x0f, 0xb7, 0x42, 0x02, 0x0f, 0xb7, 0x5a, 0x2a, 0x33, 0xc3,
  0x66, 0x89, 0x42, 0x02, 0x0f, 0xb7, 0x42, 0x28, 0x0f, 0xb7, 0x5a, 0x36,
  0x33, 0xc3, 0x66, 0x89, 0x42, 0x28, 0x0f, 0xb7, 0x42, 0x0c, 0x0f, 0xb7,
  0x5a, 0x0e, 0x33, 0xc3, 0x66, 0x89, 0x42, 0x0c, 0x80, 0xf9, 0x01, 0x75,
  0x02, 0x0f, 0x05, 0x0f, 0xb7, 0x42, 0x26, 0x83, 0xe8, 0x05, 0x66, 0x89,
  0x42, 0x26, 0x0f, 0xb7, 0x42, 0x1a, 0x83, 0xe8, 0x05, 0x66, 0x89, 0x42,
  0x1a, 0x0f, 0xb7, 0x02, 0x83, 0xe8, 0x05, 0x66, 0x89, 0x02, 0x0f, 0xb7,
  0x42, 0x06, 0x83, 0xe8, 0x05, 0x66, 0x89, 0x42, 0x06, 0x80, 0xf9, 0x02,
  0x75, 0x02, 0x0f, 0x05, 0x0f, 0xb7, 0x42, 0x04, 0x83, 0xc0, 0x14, 0x66,
  0x89, 0x42, 0x04, 0x0f, 0xb7, 0x42, 0x08, 0x83, 0xc0, 0x14, 0x66, 0x89,
  0x42, 0x08, 0x0f, 0xb7, 0x42, 0x18, 0x83, 0xc0, 0x14, 0x66, 0x89, 0x42,
  0x18, 0x0f, 0xb7, 0x42, 0x34, 0x83, 0xc0, 0x14, 0x66, 0x89, 0x42, 0x34,
  0x80, 0xf9, 0x03, 0x75, 0x02, 0x0f, 0x05, 0x0f, 0xb7, 0x42, 0x04, 0x0f,
  0xb7, 0x5a, 0x08, 0x33, 0xc3, 0x66, 0x89, 0x42, 0x04, 0x0f, 0xb7, 0x42,
  0x06, 0x0f, 0xb7, 0x5a, 0x08, 0x33, 0xc3, 0x66, 0x89, 0x42, 0x06, 0x0f,
  0xb7, 0x42, 0x24, 0x0f, 0xb7, 0x5a, 0x18, 0x33, 0xc3, 0x66, 0x89, 0x42,
  0x24, 0x0f, 0xb7, 0x42, 0x16, 0x0f, 0xb7, 0x5a, 0x34, 0x33, 0xc3, 0x66,
  0x89, 0x42, 0x16, 0x80, 0xf9, 0x04, 0x75, 0x02, 0x0f, 0x05, 0x0f, 0xb7,
  0x42, 0x22, 0x83, 0xf0, 0x29, 0x66, 0x89, 0x42, 0x22, 0x0f, 0xb7, 0x42,
  0x3a, 0x83, 0xf0, 0x29, 0x66, 0x89, 0x42, 0x3a, 0x0f, 0xb7, 0x42, 0x08,
  0x83, 0xf0, 0x29, 0x66, 0x89, 0x42, 0x08, 0x0f, 0xb7, 0x42, 0x02, 0x83,
  0xf0, 0x29, 0x66, 0x89, 0x42, 0x02, 0x80, 0xf9, 0x05, 0x75, 0x02, 0x0f,
  0x05, 0x0f, 0xb7, 0x42, 0x0a, 0x0f, 0xb7, 0x5a, 0x22, 0x33, 0xc3, 0x66,
  0x89, 0x42, 0x0a, 0x0f, 0xb7, 0x42, 0x10, 0x0f, 0xb7, 0x5a, 0x3a, 0x33,
  0xc3, 0x66, 0x89, 0x42, 0x10, 0x0f, 0xb7, 0x42, 0x38, 0x0f, 0xb7, 0x5a,
  0x08, 0x33, 0xc3, 0x66, 0x89, 0x42, 0x38, 0x0f, 0xb7, 0x42, 0x12, 0x0f,
  0xb7, 0x5a, 0x02, 0x33, 0xc3, 0x66, 0x89, 0x42, 0x12, 0x80, 0xf9, 0x06,
  0x75, 0x02, 0x0f, 0x05, 0x0f, 0xb7, 0x42, 0x30, 0x83, 0xe8, 0x09, 0x66,
  0x89, 0x42, 0x30, 0x0f, 0xb7, 0x42, 0x0c, 0x83, 0xe8, 0x09, 0x66, 0x89,
  0x42, 0x0c, 0x0f, 0xb7, 0x42, 0x32, 0x83, 0xe8, 0x09, 0x66, 0x89, 0x42,
  0x32, 0x0f, 0xb7, 0x42, 0x20, 0x83, 0xe8, 0x09, 0x66, 0x89, 0x42, 0x20,
  0x80, 0xf9, 0x07, 0x75, 0x02, 0x0f, 0x05, 0x0f, 0xb7, 0x42, 0x14, 0x83,
  0xe8, 0x02, 0x66, 0x89, 0x42, 0x14, 0x0f, 0xb7, 0x42, 0x1c, 0x83, 0xe8,
  0x02, 0x66, 0x89, 0x42, 0x1c, 0x0f, 0xb7, 0x42, 0x0e, 0x83, 0xe8, 0x02,
  0x66, 0x89, 0x42, 0x0e, 0x0f, 0xb7, 0x42, 0x3e, 0x83, 0xe8, 0x02, 0x66,
  0x89, 0x42, 0x3e, 0x80, 0xf9, 0x08, 0x75, 0x02, 0x0f, 0x05, 0x0f, 0xb7,
  0x42, 0x12, 0x83, 0xc0, 0x0d, 0x66, 0x89, 0x42, 0x12, 0x0f, 0xb7, 0x42,
  0x2e, 0x83, 0xc0, 0x0d, 0x66, 0x89, 0x42, 0x2e, 0x0f, 0xb7, 0x42, 0x3c,
  0x83, 0xc0, 0x0d, 0x66, 0x89, 0x42, 0x3c, 0x0f, 0xb7, 0x42, 0x1e, 0x83,
  0xc0, 0x0d, 0x66, 0x89, 0x42, 0x1e, 0x80, 0xf9, 0x09, 0x75, 0x02, 0x0f,
  0x05, 0x6a, 0x00, 0xe8, 0x89, 0x00, 0x00, 0x00};

uint32_t ecx = 0;
uint32_t eip = 0;
uint32_t edx = 0;

char flag[65] = "";
size_t flag_len = 32;

char buf[65] = "";
size_t buf_index = 0;
size_t buf_len = 0;

#ifdef DEBUG
int syscall_count = 0; //debug
#endif

#ifdef DEBUG
void hook_code(uc_engine *uc, uint64_t address, uint32_t size, void *user_data) {
    uint32_t eip = 0;
    uc_reg_read(uc, UC_X86_REG_EIP, &eip);
    printf(">>> Executing instruction at 0x%" PRIx32 ", EIP = 0x%" PRIx32 "\n", address, eip);
    printf("\n");
}
#endif

static void hook_syscall(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
    uc_reg_read(uc, UC_X86_REG_ECX, &ecx);
    uc_reg_read(uc, UC_X86_REG_EIP, &eip);

    #ifdef DEBUG
    syscall_count++;
    printf("\n==== HOOK ====\n");
    printf("Syscall #%d intercepted!\n", syscall_count); //debug
    printf("  EIP = 0x%" PRIx64 "\n", (uint64_t)eip);
    printf("  ECX (syscall number) = %u\n", ecx);
    #endif

    if (buf_index >= buf_len) {
        uc_emu_stop(uc);
        return;
    }
    // printf("buf_index: %d\n", buf[buf_index] - '0');
    uint32_t new_ecx = (uint32_t)(buf[buf_index++] - '0');
    uint32_t new_eip = ADDRESS_CODE-2;
    
    uc_reg_write(uc, UC_X86_REG_ECX, &new_ecx);
    uc_reg_write(uc, UC_X86_REG_EIP, &new_eip); 

    #ifdef DEBUG
    printf("Setting ECX to: %u\n", new_ecx);
    printf("Setting EIP to: 0x%x\n", new_eip);
    #endif
    

    unsigned char output_flag[flag_len * 2 + 1];
    uc_mem_read(uc, FLAG_ADDRESS, (uint8_t*)output_flag, flag_len * 2);
    output_flag[flag_len * 2] = '\0';

    #ifdef DEBUG

    // printf("%d\n", (int)flag_len);
    printf("Flag in memory: ");

    for (int i = 0; i < (int)flag_len*2; i++) {
        printf("%c", output_flag[i]);
    }
    printf("\n");
    for (int i = 0; i < (int)flag_len*2; i++) {
        printf("%d ", output_flag[i]);
    }
    printf("\n");
    printf("\n==== HOOK ====\n");
    #endif
}

int main(int argc, char* argv[])
{
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <???>\n", argv[0]);
        return -1;
    }

    flag_len = (strlen(argv[1]) > 32) ? 32 : strlen(argv[1]);

    for(int i=0; i<(int)strlen(argv[1]); i++) {
        flag[2*i] = argv[1][i];
        flag[2*i+1] = '\0';
    }

    
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘                                                       â•‘\n");
    printf("â•‘             The binary taste gooooooood!!!            â•‘\n");
    printf("â•‘                 (by. Adb2 & nyanfox.)                 â•‘\n");
    printf("â•‘                                                       â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    #ifdef DEBUG
    for(int i=0; i<(int)strlen(argv[1]); i++){ //debug
        printf("%d %d ", flag[2*i], flag[2*i+1]);
    }
    printf("\n");
    #endif

    // output time to user
    time_t now = time(nullptr);
    tm* localTime = localtime(&now);
    strftime(buf, sizeof(buf), "%Y/%m/%d/%H/%M/%S", localTime);
    printf("Current Timestamp: %s\n", buf);
    strftime(buf, sizeof(buf), "%S%Y%d%m%M%H%S%M%H%Y%d%m", localTime);
    
    // printf("Key: %s\n", buf);
    

    // strcpy(buf, "14202501080214");

    buf_len = strlen(buf);
    buf_index = 0;

    uc_engine* uc;

    uc_open(UC_ARCH_X86, UC_MODE_32, &uc);

    uc_mem_map(uc, ADDRESS_CODE, CODE_SIZE, UC_PROT_ALL);
    uc_mem_map(uc, ADDRESS_STAK, STAK_SIZE, UC_PROT_ALL);

    // uint32_t sp = (ADDRESS_STAK + STAK_SIZE - 0x100) & 0xFFFFFFFF;
    // uc_reg_write(uc, UC_X86_REG_ESP, &sp);

    uc_mem_write(uc, ADDRESS_CODE, CORN, sizeof(CORN));
    uc_mem_write(uc, FLAG_ADDRESS, (const uint8_t*)flag, flag_len*2);

    // set first ecx
    // ecx = 10;
    // strcpy(buf, "01000001");
    ecx = buf[buf_index++] - '0';
    // ecx = 0;
    edx = FLAG_ADDRESS;
    uc_reg_write(uc, UC_X86_REG_ECX, &ecx);
    uc_reg_write(uc, UC_X86_REG_EDX, &edx);

    uc_hook syscall_hook;
    uc_hook hlt_hook;
    uc_hook_add(uc, &syscall_hook, UC_HOOK_INSN, (void*)hook_syscall,
        nullptr, ADDRESS_CODE, ADDRESS_CODE + sizeof(CORN) - 1, UC_X86_INS_SYSCALL);

    // uc_hook_add(uc, &hlt_hook, UC_HOOK_INSN, (void*)hook_syscall,
    //     nullptr, ADDRESS_CODE, ADDRESS_CODE + sizeof(CODE) - 1, UC_X86_INS_HLT);

    // uc_hook trace;
    // uc_hook_add(uc, &trace, UC_HOOK_CODE, (void*)hook_code, NULL, ADDRESS_CODE, ADDRESS_CODE + sizeof(CODE));

    uc_reg_read(uc, UC_X86_REG_ECX, &ecx);
    uc_reg_read(uc, UC_X86_REG_EIP, &eip);

    #ifdef DEBUG
    printf("\n\n========= TEST =========\n");
    printf("Before emulation: ECX=0x%" PRIx64 ", EIP=0x%" PRIx64 "\n", (uint64_t)ecx, (uint64_t)eip);
    #endif


    uc_emu_start(uc, ADDRESS_CODE, ADDRESS_CODE + sizeof(CORN) , 0, 0);

    uc_reg_read(uc, UC_X86_REG_ECX, &ecx);
    uc_reg_read(uc, UC_X86_REG_EIP, &eip);

    #ifdef DEBUG
    printf("After emulation: ECX=0x%" PRIx64 ", EIP=0x%" PRIx64 "\n", (uint64_t)ecx, (uint64_t)eip);
    printf("\n\n========= TEST =========\n");
    #endif

    short int output_flag[flag_len + 1];
    uc_mem_read(uc, FLAG_ADDRESS, (uint8_t*)output_flag, flag_len * 2);
    output_flag[flag_len] = '\0';


    // output to user
    // printf("%d", (int)flag_len);
    printf("enc_flag: [");

    for (int i = 0; i < (int)flag_len; i++) {
        if (i > 0) printf(",");
        // printf("\"\\x%02x\"", output_flag[i]);
        printf("0x%02x", output_flag[i] & 0xFFFF);
    }

    // printf("\n");
    // for (int i = 0; i < (int)flag_len * 2; i++) {
    //     printf("%c", (unsigned char)output_flag[i]);
    // }
    // printf("\n");
    
    // #ifdef DEBUG
    // for (int i = 0; i < (int)flag_len*2; i++) {
    //     printf("%d ", output_flag[i]);
    // }
    // printf("\n");
    // #endif

    printf("]\nCheck corn: ");
    fflush(stdout);
    char input[33];
    scanf("%32s", input);

    if (strcmp(input, argv[1]) == 0) {
        printf("You got my unique cornðŸŒ½! Meow~\n");
    } else {
        printf("Wrong corn!\n");
    }


    uc_close(uc);
    return 0;
}
